<?php

use Swaggest\JsonSchema\Schema;

require __DIR__ . '/../../../../vendor/autoload.php';

$blueprintSchema = json_decode( file_get_contents( __DIR__ . '/../schema.json' ) );

$schema = Schema::import( $blueprintSchema );

$targetPath = __DIR__ . '/../Model';
if ( ! file_exists( $targetPath ) ) {
	mkdir( $targetPath, 0777, true );
}
$dataClassNs = 'WordPress\\Blueprints\\Model\\DataClass';
$builderNs   = 'WordPress\\Blueprints\\Model\\Builder';
$handlerNs   = 'WordPress\\Blueprints\\StepHandler';

/**
 * Same as \Swaggest\PhpCodeBuilder\App\PhpApp. but does not
 * remove everything from the $targetPath directory. We store
 * more than just the autogenerated files in there and we don't
 * want to remove them. This version of the class only clears
 * the directories associated with the namespaces we use for
 * the generated classes.
 */
class CarefulPhpApp extends \Swaggest\PhpCodeBuilder\App\PhpApp {
	protected $psr4Namespaces = [];
	protected $directoriesToClear = [];

	public function setNamespaceRoot( $namespace, $relativePath = './src/', $clear = true ) {
		$relativePath                       = rtrim( $relativePath, '/' ) . '/';
		$this->psr4Namespaces[ $namespace ] = $relativePath;
		parent::setNamespaceRoot( $namespace, $relativePath );

		if ( $clear ) {
			$this->directoriesToClear[] = $relativePath;
		}

		return $this;
	}

	public function generatedClassExists( $rootPath, $namespace, $className ) {
		$namespacePath = $this->psr4Namespaces[ $namespace ];
		$rootPath      = rtrim( $rootPath, '/' ) . '/';
		$classPath     = $rootPath . $namespacePath . $className . '.php';

		return file_exists( $classPath );
	}

	public function store( $path ) {
		foreach ( $this->directoriesToClear as $relativePath ) {
			$dir = realpath( $path . $relativePath );
			foreach ( glob( $dir . '/*.php' ) as $oldFile ) {
				unlink( $oldFile );
			}
		}

		if ( DIRECTORY_SEPARATOR === '\\' ) {
			$path = str_replace( '\\', '/', $path );
		}

		$path = rtrim( $path, '/' ) . '/';

		foreach ( $this->files as $filepath => $contents ) {
			$this->putContents( $path . $filepath, $contents );
		}
	}

}

$app = new CarefulPhpApp();
$app->setNamespaceRoot( $dataClassNs, './DataClass' );
$app->setNamespaceRoot( $builderNs, './Builder' );
$app->setNamespaceRoot( $handlerNs, '../StepHandler' );

$builder                          = new \Swaggest\PhpCodeBuilder\JsonSchema\PhpBuilder();
$builder->buildSetters            = true;
$builder->makeEnumConstants       = true;
$builder->declarePropertyDefaults = true;

$builder->classCreatedHook = new \Swaggest\PhpCodeBuilder\JsonSchema\ClassHookCallback(
	function ( \Swaggest\PhpCodeBuilder\PhpClass $class, $path, $schema ) use ( $app, $builderNs ) {
		$desc = '';
		if ( $schema->title ) {
			$desc = $schema->title;
		}
		if ( $schema->description ) {
			$desc .= "\n" . $schema->description;
		}
		if ( $fromRefs = $schema->getFromRefs() ) {
			$desc .= "\nBuilt from " . implode( "\n" . ' <- ', $fromRefs );
		}

		$class->setDescription( trim( $desc ) );
		$class->setNamespace( $builderNs );
		if ( '#' === $path ) {
			$class->setName( 'Blueprint' ); // Class name for root schema
		} elseif ( strpos( $path, '#/definitions/' ) === 0 ) {
			$class->setName(
				\Swaggest\PhpCodeBuilder\PhpCode::makePhpClassName( substr( $path, strlen( '#/definitions/' ) ) ) . 'Builder'
			);
		}
		$app->addClass( $class );
	}
);

// Add a FileReference interface
// I didn't find any way of getting those information from $schema,
// so here's a native extraction of all the FileReference classes
$fileReferences       = $blueprintSchema->definitions->FileReference;
$fileReferenceClasses = [];
foreach ( $fileReferences->anyOf as $name => $property ) {
	if ( $property->{'$ref'} ) {
		$parts                         = explode( '/', $property->{'$ref'} );
		$fileReferenceClasses[ $name ] = end( $parts );
	}
}
$fileReferenceInterface = ( new \Swaggest\PhpCodeBuilder\PhpInterface() )
	->setName( 'FileReferenceInterface' )
	->setNamespace( $dataClassNs );
$app->addClass( $fileReferenceInterface );

$builder->classPreparedHook = new \Swaggest\PhpCodeBuilder\JsonSchema\ClassHookCallback(
	function ( \Swaggest\PhpCodeBuilder\PhpClass $class, $path, $schema ) use (
		$app,
		$targetPath,
		$builderNs,
		$dataClassNs,
		$handlerNs,
		$fileReferenceInterface,
		$fileReferenceClasses
	) {
		$dataClass = new \Swaggest\PhpCodeBuilder\PhpClass();
		// Remove the "Builder" suffix from the class name
		$dataClassName = substr( $class->getName(), 0, - 7 );
		$dataClass->setName( $dataClassName );
		$dataClass->setNamespace( $dataClassNs );
		// Add all the properties from the builder class to the data class
		foreach ( $class->getProperties() as $property ) {
			$dataClass->addProperty( $property );
		}
		if ( in_array( $dataClassName, $fileReferenceClasses ) ) {
			$dataClass->addImplements( $fileReferenceInterface );
		}

		// ...and remove them from the builder class â€“ they will be inherited
		$ref  = new ReflectionObject( $class );
		$prop = $ref->getProperty( 'properties' );
		$prop->setAccessible( true );
		$prop->setValue( $class, [] );

		// Add default values for the "const" properties
		$schemaProperties = $schema->getProperties();
		foreach ( $dataClass->getProperties() as $property ) {
			$name = $property->getNamedVar()->getName();
			if ( $schemaProperties->$name && $schemaProperties->$name->const ) {
				$property->getNamedVar()->setDefault( $schemaProperties->$name->const );
			}
		};

		// Add a toDataObject method to the builder class that will return a new instance of the data class
		$toDataObjectBody = "\$dataObject = new $dataClassName();\n";
		foreach ( $dataClass->getProperties() as $property ) {
			$name             = $property->getNamedVar()->getName();
			$toDataObjectBody .= "\$dataObject->$name = \$this->recursiveJsonSerialize(\$this->{$name});\n";
		}
		$toDataObjectBody .= 'return $dataObject;';
		$class->addMethod( ( new \Swaggest\PhpCodeBuilder\PhpFunction( 'toDataObject' ) )->setBody( $toDataObjectBody ) );
		$class->addMethod( ( new \Swaggest\PhpCodeBuilder\PhpFunction( 'recursiveJsonSerialize' ) )->addArgument(
			new \Swaggest\PhpCodeBuilder\PhpNamedVar( 'objectMaybe' )
		)->setVisibility( 'private' )->setBody( <<<'METHOD'
if ( is_array( $objectMaybe ) ) {
	return array_map([$this, 'recursiveJsonSerialize'], $objectMaybe);
} elseif ( $objectMaybe instanceof \Swaggest\JsonSchema\Structure\ClassStructureContract ) {
	return $objectMaybe->toDataObject();
} else {
	return $objectMaybe;
}
METHOD
		) );

		// We want to extend the data class so let's replace the default inheritance
		// approach in the schema class with a trait and an interface
		$class->setExtends( $dataClass );
		$class->addTrait( new \Swaggest\PhpCodeBuilder\PhpTrait( '\\Swaggest\\JsonSchema\\Structure\\ClassStructureTrait' ) );
		$class->addImplements( ( new \Swaggest\PhpCodeBuilder\PhpInterface() )->setName( '\\Swaggest\\JsonSchema\\Structure\\ClassStructureContract' ) );

		$app->addClass( $dataClass );

		$handlerClassName = $dataClassName . 'Handler';
		// Create a handler class if it's missing
		if ( ! $app->generatedClassExists( $targetPath, $handlerNs, $handlerClassName ) ) {
			$baseStepHandlerClass = new \Swaggest\PhpCodeBuilder\PhpClass();
			$baseStepHandlerClass->setNamespace( 'WordPress\\Blueprints\\StepHandler' );
			$baseStepHandlerClass->setName( 'BaseStepHandler' );

			$handlerClass = new \Swaggest\PhpCodeBuilder\PhpClass();
			$handlerClass->setNamespace( $handlerNs );
			$handlerClass->setExtends( $baseStepHandlerClass );
			$handlerClass->setName( $handlerClassName );
			$execute = new \Swaggest\PhpCodeBuilder\PhpFunction( 'execute' );
			$execute->setBody( '' );
			$input = new \Swaggest\PhpCodeBuilder\PhpNamedVar( 'input' );
			$input->setType( $dataClass );
			$execute->addArgument( $input );
			$handlerClass->addMethod( $execute );
			$app->addClass( $handlerClass );
		}
	}
);

$builder->getType( $schema );
$app->store( $targetPath );
